# Java字节码

1. 使用javap -verbose命令分析一个字节码文件时, 将会分析该字节码的魔数, 版本号, 常量池, 类信息, 类的构造方法, 类中的方法,类变量, 成员变量等信息.
2. 魔数(Magic Number): 所有的.class文件的前4个字节都是魔数, 魔数值为固定值: 0xCAFEBABE
3. 魔数之后的4个字节为版本信息, 前两个字节表示minor version(次版本号), 后两个字节表示major version(主版本号). 当前显示为00 00 00 34, 表示次版本号0, 主版本号52(从45开始). 所以, 52的版本号对应: 1.8.0
4. 常量池(constant pool): 紧接着主版本号之后就是常量池入口. 一个Java类中定义的很多信息都是由常量池来维护和描述的, 可以将常量池看作是Class文件的资源库, 比如Java类中定义的方法与变量信息都是存储在常量池中. 常量池中主要存储两类常量: 字面量与符号引用.
    > 字面量如文本字符串, Java中声明为final的常量值等.  
    > 符号引用如类和接口的全局限定名, 字段的名称和描述符, 方法的名称和描述符.
5. 常量池的结构: 常量池数量和常量池数组(常量表)两部分构成.
    > 常量池数量紧跟在主版本号后, 占2个字节; 常量池数组紧跟在常量池数量后.  
    > 常量池数组中不同的元素的类型和结构都是不同的. 但是, 每一个元素第一个数据都是u1类型(占1个字节), 该字节是标志位. JVM在解析时, 根据u1类型来获取元素的具体类型. 常量池数组中元素的个数 = 常量池数 - 1 (0暂不使用), 索引为0也是一个常量(保留常量), 对应null值.
6. JVM规范中, 每个字段都有描述信息, 描述字段的数据类型,方法的参数列表与返回值. 根据描述符规则, 基本数据类型和void类型都用一个大写字母表示, 对象类型则用L加对象的全限定名来表示, 用于压缩字节码文件体积. 如下: B - byte, C - char, D - double, F - float, I - int, J - long, S - short, Z - boolean, V - void, L - 对象类型, Ljava/lang/String;
7. 对数组类型, 每个维度使用一个前置的[来表示, 如int[]被记录为[I, String[][]被记录为[[Ljava/lang/String;
8. 描述符描述方法时, 按照先参数列表, 后返回值的顺序来描述. 参数列表按照参数的严格顺序放在()之内.
    > 如: String getRealName(int id, String name)的描述符为: (I, Ljava/lang/String;) Ljava/lang/String

---
* Java编译器始终会把成员变量的显示初始化语句以字节码指令的形式放到每一个构造方法`<init>`开头
* 把静态变量的显示初始化和静态代码块中的语句以字节码指令的形式放到编译器生成的`<clinit>`方法中

---
### 方法表
> 对于Java类中的每一个实例方法, 其在编译后所生成的字节码当中, 方法参数的数量总是会比源代码中方法参数多一个this, 它位于方法的第一个参数位置处; 我们就能够在Java的实例方法中使用this来访问当前对象的属性和方法.  

> 这个操作是在编译器完成的, 由javac编译器在编译的时候将对this的访问转化为对实例方法普通参数的访问, 在运行期间, 由JVM在调用实例方法时, 自动向实例方法传入this参数. 所以, 在实例方法的局部变量表中, 至少有一个指向当前对象的this变量.
---

### Java字节码对异常的处理方式
1. 统一采用异常表(Start PC --- End PC --- Handler PC --- catch_type)的方式对异常进行处理.
2. 在jdk 1.4.2之前的版本中, 是采用特点的指令方式处理异常
3. 当异常处理存在finally语句块时, javac会将finally语句块的字节码拼接到catch块后面.
4. 若程序中存在多个catch块, 就会在每一个catch块后面重复finally语句块的字节码.

---
### 栈帧(stack frame)
> 栈帧是一种用于帮助JVM执行方法调用与方法执行的数据结构.  
> 栈帧本身是一种数据结构, 封装了方法的局部变量表, 动态链接信息, 方法的返回地址, 以及操作数栈等信息.  
---
> 符号引用(常量池中的字面量), 直接引用
    >* 静态解析: 符号引用在类加载阶段或是第一次使用时就会转换为直接引用
    >* 动态链接: 符号引用在每次运行期转换为直接引用, 体现为Java的多态性
---
> 字节码方法调用指令
    >* invokeinterface: 调用接口中的方法, 实际是在运行期决定调用实现该接口的哪个对象的特定方法;
    >* invokestatic: 调用静态方法
    >* invokespecial: 调用自己的私有方法, 构造方法(<init>)或父类的方法
    >* invokevirtual: 调用虚方法, 运行期间动态查找
    >* invokedynamic: 动态调用方法
---
* 静态解析的4种情形: 
    * 静态方法
    * 父类方法
    * 构造方法
    * 私有方法(无法被重写)  
以上4类方法被称作非虚方法, 在类加载阶段就可以将符号引用转换为直接引用.

* * *
1. 方法的静态分派
    > Grandpa g1 = new Father();  
    > g1静态类型是Grandpa, 而g1的实际类型是Father  
    > 变量的静态类型是不会变化的, 而变量的实际类型则是可以发生变化的(多态的体现), 实际类型在运行期才能确定, 而方法的调用是根据参数的静态类型在编译期就确定的.
2. 方法的动态分配
    > invokevirtual字节码指令的多态查找流程. 运行期根据方法接收者(调用者)的实际类型去查找, 将方法的符号引用转换为直接引用.  
    > 针对动态分配(invokevirtual)过程, JVM会在类的方法区建立一个虚方法表的数据结构(virtual method table, vtable)
    > 针对invokeinterface指令, JVM会建立一个接口方法表的数据结构(interface method table, itable)
3. 结论: 方法重载是静态的, 是编译器行为; 方法重写是动态的, 是运行期行为.

* * *
- 解释执行与编译执行(现代JVM执行Java代码, 通常将两者结合起来进行)
    * 解释执行, 就是通过解释器来读取字节码, 遇到相应的指令就去执行该指令
    * 编译执行, 就是通过即时编译器(Just In Time, JIT)将字节码转换为本地机器码来执行; 现代JVM会根据代码热点来生成相应的本地机器码.
* * *
- 基于栈的指令集与基于寄存器的指令集
    1. JVM执行指令时所采取的方式是基于栈的指令集
    2. 基于栈的指令集主要的操作有入栈和出栈两种
    3. 基于栈的指令集的优势在于可以在不同平台间移植, 而基于寄存器的指令集是与硬件架构紧密联系的, 无法做到可移植
    4. 基于栈的指令集缺点在于: 完成相同的操作, 指令集数量通常比基于寄存器的指令集数量要多; 基于栈的指令集是在内存中完成操作, 而基于寄存器的指令集是在CPU高速缓冲区中完成操作, 速度要快很多.